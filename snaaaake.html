<!DOCTYPE html>
<html>
<head>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.15.1/dist/phaser-arcade-physics.min.js"></script>
</head>
<body>
<<<<<<< HEAD
  <script>
    var MainGame = new Phaser.Class({
      Extends: Phaser.Scene,

      initialize:

        function MainGame() {
          Phaser.Scene.call(this, {
            key: 'MainGame'
          });
        },

      grid: null,
      snake: null,
      pellet: null,
      portal: null,
      portal2: null,
      cursors: null,
      scoreText: null,


      UP: 0,
      DOWN: 1,
      LEFT: 2,
      RIGHT: 3,

      preload: function() {
=======
    <script>
      var config = {
          type: Phaser.WEBGL,
          width: 800,
          height: 630,
          scene: {
              preload: preload,
              create: create,
              update: update
          }
      };
      var game = new Phaser.Game(config);

      var grid;
      var snake;
      var pellet;
      var portal;
      var portal2;
      var cursors;
      var scoreText;

      var UP = 0;
      var DOWN = 1;
      var LEFT = 2;
      var RIGHT = 3;

      function preload()
      {
>>>>>>> 75fc69ac551026e2e67fe15378624bd2c8eaa9b9
        this.load.image('snake', 'assets/snake.png')
        this.load.image('pill', 'assets/pill.png')
        this.load.image('portal', 'assets/portal.png')
        this.load.image('wall', 'assets/wall.png')
      }

      function create()
      {
        grid = this.add.grid(0, 0, 800, 600, 20, 20, 0x000000, 1, 0xffffff, 0.5);
        grid.setOrigin(0);
        this.add.rectangle(0, 0, 800, 600)

        var Snake = new Phaser.Class(
          {
            initialize:

             function Snake (scene, x, y)
             {
                 this.headPosition = new Phaser.Geom.Point(x, y);

                 this.body = scene.add.group();

                 this.head = this.body.create(x * 20, y * 20, 'snake');

                 this.head.setOrigin(0);

                 this.alive = true;



                 this.speed = 100;


                 this.moveTime = 0;

                 this.tail = new Phaser.Geom.Point(x, y);

                 this.score = 0

                 this.heading = null;
                 this.direction = null;
             },

             update: function (time)
             {
                 if (time >= this.moveTime)
                 {
                     return this.move(time);
                 }
             },

             faceLeft: function ()
             {
                 if (this.direction === UP || this.direction === DOWN || this.direction === null)
                 {
                     this.heading = LEFT;
                 }
             },

             faceRight: function ()
             {
                 if (this.direction === UP || this.direction === DOWN || this.direction === null)
                 {
                     this.heading = RIGHT;
                 }
             },

            faceUp: function ()
             {
                 if (this.direction === LEFT || this.direction === RIGHT || this.direction === null)
                 {
                     this.heading = UP;
                 }
             },

             faceDown: function ()
             {
                 if (this.direction === LEFT || this.direction === RIGHT || this.direction === null)
                 {
                     this.heading = DOWN;
                 }
             },

             move: function (time)
             {
               switch (this.heading)
              {
                    case LEFT:
                        this.headPosition.x = this.headPosition.x - 1
                        break;

                    case RIGHT:
                        this.headPosition.x = this.headPosition.x + 1
                        break;

                    case UP:
                        this.headPosition.y = this.headPosition.y - 1
                        break;

                    case DOWN:
                        this.headPosition.y = this.headPosition.y + 1
                        break;
              }

                 this.direction = this.heading;
                 Phaser.Actions.ShiftPosition(this.body.getChildren(), this.headPosition.x * 20, this.headPosition.y * 20, 1, this.tail);
                 this.moveTime = time + this.speed;
                 return true;
             },

             grow: function(){
               var newPart = this.body.create(this.tail.x, this.tail.y, 'snake');
               this.score += 1
               newPart.setOrigin(0);
               scoreText.setText('Score: ' + snake.score)
             },


             collideWithFood : function (pill){
               if(this.headPosition.x === (pill.x / 20) && this.headPosition.y === (pill.y / 20))
               {
                 pill.consume();
                 this.grow()

               }
             },

             collideWithPortal: function(portal)
              {
               if((this.headPosition.x === (portal.x / 20) || this.headPosition.x === (portal.x + 1 / 20)) && (this.headPosition.y === (portal.y / 20) || this.headPosition.y === (portal.y + 1 / 20)))
               {
                 //portal.reset();
                 this.headPosition.x = portal.sisterX / 20;
                 this.headPosition.y = portal.sisterY / 20;
                 //if(this.headPosition.x === (portal.x + 1 / 20))
                 //  this.headPosition.x += 1;
                 //if(this.headPosition.y === (portal.x + 1 / 20))
                 //  this.headPosition.x += 1;
                 //Phaser.Actions.ShiftPosition(this.body.getChildren(), portal.sisterX / 20, portal.sisterY / 20, 1, this.tail);
                 return true;
               }
               return false;
             }
         });

         var Pill = new Phaser.Class({

           Extends: Phaser.GameObjects.Image,

           initialize:

           function Pill(scene, x, y)
           {
            Phaser.GameObjects.Image.call(this, scene)

            this.setTexture('pill');
            this.setPosition(x * 20, y * 20);
            this.setOrigin(0);

<<<<<<< HEAD
          collideWithPortal: function(portal) {
            if (this.headPosition.x === (portal.x / 20) && this.headPosition.y === (portal.y / 20)) {
              //portal.reset();
              this.headPosition.x = portal.sisterX / 20;
              this.headPosition.y = portal.sisterY / 20;
              return true;
            }
            return false;
          }
        });
=======
            this.total = 0;
>>>>>>> 75fc69ac551026e2e67fe15378624bd2c8eaa9b9

            scene.children.add(this);
           },

           consume: function(){
             var x = Phaser.Math.Between(0, 39);
             var y = Phaser.Math.Between(0, 29);

             this.setPosition(x * 20, y * 20);
           }

         });

         var Wall = new Phaser.Class({

           Extends: Phaser.GameObjects.Image,

           initialize:

           function Wall(scene, x, y)
           {
            Phaser.GameObjects.Image.call(this, scene)

            this.setTexture('wall');
            this.setPosition(x * 20, y * 20);
            this.setOrigin(0);

            this.total = 0;

            scene.children.add(this);
          },

          collideWithSnake: function(snake)
          {
            if(snake.headPosition.x === this.x ||
                snake.headPosition.x === this.x + 1 ||
                snake.headPosition.y === this.y ||
                snake.headPosition.y === this.y + 1)
                return true;
            else {
              return false;
            }
          }
         });

         var Portal = new Phaser.Class({
           Extends: Phaser.GameObjects.Image,

           initialize:

           function Portal(scene, x, y)
           {
             Phaser.GameObjects.Image.call(this, scene)

             this.setTexture("portal")
             this.setPosition(x * 20, y * 20)
             this.setOrigin(0)
             this.sisterX = 0;
             this.sisterY = 0;
             scene.children.add(this)
           },

           link: function(portal)
           {
             this.sisterX = portal.x;
             this.sisterY = portal.y;
           },

           reset: function(){
             var x = Phaser.Math.Between(0, 39);
             var y = Phaser.Math.Between(0, 29);

             this.setPosition(x * 20, y * 20);
           },
         })



         snake = new Snake(this, Math.floor(Math.random() * 40), Math.floor(Math.random() * 30));
         pill = new Pill(this, Math.floor(Math.random() * 40), Math.floor(Math.random() * 30));
         portal = new Portal(this, 10, 15);
         portal2 = new Portal(this,30, 15);
         portal.link(portal2);
         portal2.link(portal);

         for(var i = 0; i < 39; i++)
         {
           var wall = new Wall(this, i, 0);
         }
         for(var i = 0; i < 39; i++)
         {
           var wall = new Wall(this, i, 29);
         }
         for(var i = 0; i < 29; i++)
         {
           var wall = new Wall(this, 0, i);
         }
         for(var i = 0; i < 30; i++)
         {
           var wall = new Wall(this, 39, i);
         }

         cursors = this.input.keyboard.createCursorKeys();
         toDisplay = "Score: " + snake.score
         scoreText = this.add.text(16, 600, toDisplay, { fontSize: '32px'})
     }

     function update (time, delta)
     {
         if (!snake.alive)
         {
             return;
         }

         if (cursors.left.isDown)
         {
             snake.faceLeft();
         }
         else if (cursors.right.isDown)
         {
             snake.faceRight();
         }
         else if (cursors.up.isDown)
         {
             snake.faceUp();
         }
         else if (cursors.down.isDown)
         {
             snake.faceDown();
         }

         if(snake.update(time))
         {
           snake.collideWithFood(pill);
           if(!snake.collideWithPortal(portal))
           {
             snake.collideWithPortal(portal2)
           }
         }

         if(cursors.space.isDown)
         {
           this.input.keyboard.resetKeys()
           snake.grow();
       }
     }
    </script>
</body>
</html>
